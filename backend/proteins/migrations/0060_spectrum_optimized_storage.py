# Generated by Django 5.2.8 on 2025-11-26 20:21

from __future__ import annotations

import struct

from django.db import connection, migrations, models


def encode_y_values(y_list: list[float]) -> bytes:
    """Encode list of floats to float32 binary data."""
    return struct.pack(f"<{len(y_list)}f", *y_list)


def column_exists(table: str, column: str) -> bool:
    """Check if a column exists in the database."""
    with connection.cursor() as cursor:
        cursor.execute(
            """
            SELECT COUNT(*) FROM information_schema.columns
            WHERE table_name = %s AND column_name = %s
            """,
            [table, column],
        )
        row = cursor.fetchone()
        return row is not None and row[0] > 0


def migrate_spectrum_data(apps, schema_editor):
    """Convert legacy data format to optimized storage format."""
    Spectrum = apps.get_model("proteins", "Spectrum")
    FluorState = apps.get_model("proteins", "FluorState")

    # Check if migration already happened (y_values populated)
    if Spectrum.objects.filter(y_values__isnull=False).exists():
        print("\n  Data already migrated, skipping...")
        return

    # Process in batches to avoid memory issues
    batch_size = 500
    total = Spectrum.objects.count()
    print(f"\nMigrating {total} spectra to optimized storage format...")

    for offset in range(0, total, batch_size):
        spectra = list(
            Spectrum.objects.select_related("owner_fluor")
            .order_by("id")[offset : offset + batch_size]
        )

        for spectrum in spectra:
            if not spectrum.data:
                print(f"  Warning: Spectrum {spectrum.id} has no data, skipping")
                continue

            # Extract wavelengths and y values from legacy format
            wavelengths = [int(point[0]) for point in spectrum.data]
            y_values = [point[1] for point in spectrum.data]

            # Set min/max wave
            spectrum.min_wave = min(wavelengths)
            spectrum.max_wave = max(wavelengths)

            # Encode y values as float32 binary
            spectrum.y_values = encode_y_values(y_values)

            # Populate scale_factor from owner based on subtype
            if spectrum.owner_fluor_id:
                try:
                    fluor = FluorState.objects.get(pk=spectrum.owner_fluor_id)
                    if spectrum.subtype in ("ex", "ab"):
                        spectrum.scale_factor = fluor.ext_coeff
                    elif spectrum.subtype == "em":
                        spectrum.scale_factor = fluor.qy
                    elif spectrum.subtype == "2p":
                        spectrum.scale_factor = fluor.twop_peak_gm
                except FluorState.DoesNotExist:
                    pass
            else:
                # For filters, cameras, lights - scale_factor is 1.0
                spectrum.scale_factor = 1.0

            spectrum.save(
                update_fields=[
                    "min_wave",
                    "max_wave",
                    "y_values",
                    "scale_factor",
                ]
            )

        print(f"  Processed {min(offset + batch_size, total)}/{total} spectra")


def add_field_if_not_exists(schema_editor, model, field_name, field):
    """Add a field only if it doesn't already exist in the database."""
    table_name = model._meta.db_table
    if not column_exists(table_name, field_name):
        schema_editor.add_field(model, field)
    else:
        print(f"  Column {field_name} already exists, skipping add...")


def remove_field_if_exists(schema_editor, model, field_name, field):
    """Remove a field only if it exists in the database."""
    table_name = model._meta.db_table
    if column_exists(table_name, field_name):
        schema_editor.remove_field(model, field)
    else:
        print(f"  Column {field_name} doesn't exist, skipping remove...")


class ConditionalAddField(migrations.AddField):
    """AddField that skips if column already exists."""

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = to_state.apps.get_model(app_label, self.model_name)
        if not column_exists(model._meta.db_table, self.field.db_column or self.name):
            super().database_forwards(app_label, schema_editor, from_state, to_state)


class ConditionalRemoveField(migrations.RemoveField):
    """RemoveField that skips if column doesn't exist."""

    def database_forwards(self, app_label, schema_editor, from_state, to_state):
        model = from_state.apps.get_model(app_label, self.model_name)
        if column_exists(model._meta.db_table, self.name):
            super().database_forwards(app_label, schema_editor, from_state, to_state)


class Migration(migrations.Migration):
    dependencies = [
        ("proteins", "0059_add_fluorophore_and_new_models"),
    ]

    operations = [
        # Step 1: Add new fields (nullable initially for migration)
        # Uses conditional add to handle re-running after partial migration
        ConditionalAddField(
            model_name="spectrum",
            name="min_wave",
            field=models.SmallIntegerField(
                blank=True,
                null=True,
                help_text="Minimum wavelength in nm (inclusive)",
            ),
        ),
        ConditionalAddField(
            model_name="spectrum",
            name="max_wave",
            field=models.SmallIntegerField(
                blank=True,
                null=True,
                help_text="Maximum wavelength in nm (inclusive)",
            ),
        ),
        ConditionalAddField(
            model_name="spectrum",
            name="y_values",
            field=models.BinaryField(
                blank=True,
                null=True,
                help_text="Y values as float32 binary array, one value per nm from min to max wave",
            ),
        ),
        ConditionalAddField(
            model_name="spectrum",
            name="scale_factor",
            field=models.FloatField(
                blank=True,
                null=True,
                help_text=(
                    "Physical scaling constant. Meaning depends on subtype: "
                    "EX/ABS=extinction coeff (M^-1 cm^-1), EM=quantum yield, "
                    "2P=peak cross-section (GM), filters/cameras=1.0"
                ),
            ),
        ),
        # Step 2: Migrate data from old format to new format
        migrations.RunPython(migrate_spectrum_data, migrations.RunPython.noop),
        # Step 3: Make min_wave, max_wave, y_values required
        migrations.AlterField(
            model_name="spectrum",
            name="min_wave",
            field=models.SmallIntegerField(
                help_text="Minimum wavelength in nm (inclusive)",
            ),
        ),
        migrations.AlterField(
            model_name="spectrum",
            name="max_wave",
            field=models.SmallIntegerField(
                help_text="Maximum wavelength in nm (inclusive)",
            ),
        ),
        migrations.AlterField(
            model_name="spectrum",
            name="y_values",
            field=models.BinaryField(
                help_text="Y values as float32 binary array, one value per nm from min to max wave",
            ),
        ),
        # Step 4: Remove the legacy data field
        ConditionalRemoveField(
            model_name="spectrum",
            name="data",
        ),
    ]
